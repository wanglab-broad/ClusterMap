import scanpy as sc
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats.mstats import zscore
from tqdm import tqdm

def generate_gene_profile(spots, gene_list, use_z, is_batch,method='leiden'):
    
    '''
    Genrate gene expression profile for cell typing

    params :    - spots (dataframe) = whole dataframe (stitched data)
                - gene_list (list of ints) = list of the genes used in the dataset
                - use_z (bool) = 3D of 2D cell segmentation
                - method (str) = name of the column where results are stored
    '''

    ### reassign the cells
    dico_assign = dict([(cell, i) for i, cell in enumerate(np.unique(spots[method])[1:])] + [(-2,-1)] + [(-1,-1)])
    spots[method] = list(map(dico_assign.get, spots[method]))
    
    ### define expression vectors for cell typing
    gene_expr_vector = np.zeros((np.unique(spots[method]).shape[0] - 1, len(gene_list)))
    centroids = []
    cellposition=[]
    gene_expr = spots.groupby([method, 'geneid']).size()
    if use_z:
        for cell in tqdm(np.unique(spots[method])[1:]):
            genes = gene_expr[cell] # number of counts per gene in cell
            gene_expr_vector[cell, np.array(genes.index) - np.min(gene_list)] = genes.to_numpy()
            cell_center = list(np.mean(spots.loc[spots[method]==cell, ['spot_merged_1', 'spot_merged_2', 'spot_merged_3']], axis=0))
            if is_batch:
                cellposition.append(list(spots.loc[spots[method]==cell, 'image_position'])[0])
            centroids.append(cell_center)
    else:
        for cell in tqdm(np.unique(spots[method])[1:]):
            genes = gene_expr[cell] # number of counts per gene in cell 'leid'
            gene_expr_vector[cell, np.array(genes.index) - np.min(gene_list)] = genes.to_numpy()
            cell_center = list(np.mean(spots.loc[spots[method]==cell, ['spot_merged_1', 'spot_merged_2']], axis=0))
            if is_batch:
                cellposition.append(list(spots.loc[spots[method]==cell, 'image_position'])[0])
            centroids.append(cell_center)
    obs = pd.DataFrame(np.array(centroids), columns=['cell_center_1', 'cell_center_2', 'cell_center_3'])
    if is_batch:
        obs['position']=cellposition
    return(gene_expr_vector,obs)


def normalize_all(gene_expr, obs, var, plot=False, min_counts_cells=16, min_cells=10):
    
    '''
    Preprocessing for cell typing

    params :    - gene_expr = ndarray with the gene profile generated by function generate gene profile
                - obs (dataframe) = columns : ['origin_index', 'centroid_1', 'centroid_2', ('centroid_3')]
                                    origin_index = label of the cell in the original tile (before stitching)
                                    centroid_k = kth-coordinate of the centroid of each cell
                - plot (bool) = whether to plot the genetic distribution of genes
                - min_count_cells (int) = minimal number of counts of a cell to be not discarded
                - min_cells (int) = filter genes and erase the ones that are expressed in less than min_cells cells. 
    
    returns : AnnData Object for cell typing
    '''

    adata = sc.AnnData(gene_expr, obs=obs, var=var)
#     adata.obs['total_counts'] = total_counts
    adata.var=adata.var.rename(columns={0:'var'})
    adata.var=adata.var.set_index('var') 
    
    # calculate metrics
    sc.pp.calculate_qc_metrics(adata, percent_top=None, inplace=True)
    
    # plot information about cells
    if plot:
        sc.pl.highest_expr_genes(adata, n_top=20)

        sns.jointplot(x="total_counts", y="n_genes_by_counts", data=adata.obs, kind="hex")
        plt.xlabel("# Spots per cell")
        plt.ylabel("# Genes per cell")
        plt.show()
    
    # filter everything
    
    sc.pp.filter_cells(adata, min_genes=5) # keep cells that have at least 5 different genes
    sc.pp.filter_genes(adata, min_cells=min_cells) # keep genes that are expressed in at least 10 cells
    sc.pp.filter_cells(adata, min_counts=min_counts_cells) # keep cells that have at least 16 spots
    
    # normalize
    sc.pp.normalize_total(adata)
    sc.pp.log1p(adata)
    adata.raw = adata
    sc.pp.regress_out(adata, ['total_counts'])
    sc.pp.scale(adata)
    return(adata)


def cell_typing2spots(adata, spots, method):
    
    '''
    Assign a cell type label to each spot

    params :    - adata (AnnData) = annotated gene expression matrix
                - spots (dataframe) = spatial locations + gene identities + cell labels
                - method (str) = name of the column where the results are stored
    '''

    spots['cell_type'] = -1
    cells_unique = np.unique(spots[method])
    cells_unique = cells_unique[cells_unique>=0]

    bad_cells = np.setdiff1d(cells_unique, np.unique(adata.obs.index.to_numpy().astype(int)), assume_unique=False)
    dico_cells2celltypes = dict([(cell, int(cell_type)) for cell, cell_type in zip(adata.obs.index.to_numpy().astype(int), adata.obs['cell_type'])] + [(-1,-1)] + [(-2,-1)] + [(bad, -1) for bad in bad_cells])
    spots['cell_type'] = np.array(list(map(dico_cells2celltypes.get, spots[method])), dtype=int)